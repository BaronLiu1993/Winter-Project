def model_training_script(node_data, node_var, input_vars):
    indent = "    "
    lines = []
    model_type = node_data.get("modelType", "resnet50")
    learning_rate = node_data.get("learningRate", 0.001)
    epochs = node_data.get("epochs", 10)
    optimizer_config = node_data.get("optimizerConfig", {})
    optimizer_type = optimizer_config.get("type", "adam").lower()
    beta1 = optimizer_config.get("beta1", 0.9)
    beta2 = optimizer_config.get("beta2", 0.999)
    momentum = optimizer_config.get("momentum", 0.9)

    input_loader_var = input_vars[0] if len(input_vars) > 0 else "None"

    lines.append(f"{indent}# Node: ModelTraining {node_var}")
    lines.append(f"{indent}model_type = '{model_type}'")
    lines.append(f"{indent}if model_type.lower() == 'resnet50':")
    lines.append(f"{indent}    temp_model = torchvision.models.resnet50(pretrained=False)")
    lines.append(f"{indent}    # Adjust final layer if needed, e.g. temp_model.fc = nn.Linear(...)")
    lines.append(f"{indent}else:")
    lines.append(f"{indent}    raise ValueError(f'Unsupported model: {model_type}')")
    lines.append("")
    lines.append(f"{indent}criterion = nn.CrossEntropyLoss()")
    lines.append(f"{indent}learning_rate = {learning_rate}")
    lines.append(f"{indent}epochs = {epochs}")
    lines.append("")
    lines.append(f"{indent}optimizer_type = '{optimizer_type}'")
    lines.append(f"{indent}beta1 = {beta1}")
    lines.append(f"{indent}beta2 = {beta2}")
    lines.append(f"{indent}momentum = {momentum}")
    lines.append("")
    lines.append(f"{indent}if optimizer_type == 'adam':")
    lines.append(
        f"{indent}    temp_optimizer = optim.Adam(temp_model.parameters(), lr=learning_rate, betas=(beta1, beta2))")
    lines.append(f"{indent}elif optimizer_type == 'sgd':")
    lines.append(
        f"{indent}    temp_optimizer = optim.SGD(temp_model.parameters(), lr=learning_rate, momentum=momentum)")
    lines.append(f"{indent}else:")
    lines.append(f"{indent}    raise ValueError(f'Unsupported optimizer type: {optimizer_type}')")
    lines.append("")
    lines.append(f"{indent}temp_model.to(device)")
    lines.append(f"{indent}print('Starting training for {epochs} epochs...')")
    lines.append(f"{indent}for epoch in range(epochs):")
    lines.append(f"{indent}    temp_model.train()")
    lines.append(f"{indent}    running_loss = 0.0")
    lines.append(f"{indent}    for datapoint, labels in {input_loader_var}:")
    lines.append(f"{indent}        datapoint, labels = datapoint.to(device), labels.to(device)")
    lines.append(f"{indent}        temp_optimizer.zero_grad()")
    lines.append(f"{indent}        outputs = temp_model(datapoint)")
    lines.append(f"{indent}        loss = criterion(outputs, labels)")
    lines.append(f"{indent}        loss.backward()")
    lines.append(f"{indent}        temp_optimizer.step()")
    lines.append(f"{indent}        running_loss += loss.item()")
    lines.append(f"{indent}    avg_loss = running_loss / len({input_loader_var})")
    lines.append(f"{indent}    print(f'Epoch [{{epoch+1}}/{{epochs}}], Loss: {{avg_loss:.4f}}')")
    lines.append("")
    lines.append(f"{indent}print('Training complete!')")
    lines.append(f"{indent}{node_var} = temp_model  # the final trained model")
    lines.append("")
    return lines

